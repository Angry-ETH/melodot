// Copyright 2023 ZeroDAO

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::melodot::runtime_types::melo_das_primitives::crypto::{KZGCommitment, KZGProof};
use crate::Client;
use melo_core_primitives::SidecarMetadata;
use melo_das_primitives::crypto::{KZGCommitment as KZGCommitmentT, KZGProof as KZGProofT};

pub use primitive_types::H256;

/// Converts a given byte length to sidecar metadata suitable for runtime.
///
/// # Arguments
///
/// - `bytes_len`: Length of random bytes to generate.
///
/// # Returns
///
/// - `Vec<KZGCommitment>`: Vector of KZG commitments for runtime.
/// - `Vec<KZGProof>`: Vector of KZG proofs for runtime.
/// - `H256`: Hash value of the blobs.
/// - `Vec<u8>`: Randomly generated bytes.
pub fn sidecar_metadata_runtime(
	bytes_len: u32,
) -> (Vec<KZGCommitment>, Vec<KZGProof>, H256, Vec<u8>) {
	let (commits, proofs, blobs_hash, bytes) = sidecar_metadata(bytes_len);
	(commitments_to_runtime(commits), proofs_to_runtime(proofs), blobs_hash, bytes)
}

/// Generates sidecar metadata based on a given byte length.
///
/// # Arguments
///
/// - `bytes_len`: Length of random bytes to generate.
///
/// # Returns
///
/// - `Vec<KZGCommitmentT>`: Vector of KZG commitments.
/// - `Vec<KZGProofT>`: Vector of KZG proofs.
/// - `H256`: Hash value of the blobs.
/// - `Vec<u8>`: Randomly generated bytes.
pub fn sidecar_metadata(bytes_len: u32) -> (Vec<KZGCommitmentT>, Vec<KZGProofT>, H256, Vec<u8>) {
	let bytes = (0..bytes_len).map(|_| rand::random::<u8>()).collect::<Vec<u8>>();
	let metadata: SidecarMetadata = SidecarMetadata::try_from_app_data(&bytes).unwrap();
	(metadata.commitments, metadata.proofs, metadata.blobs_hash, bytes)
}

/// Converts KZG commitments to a runtime-friendly format.
///
/// # Arguments
///
/// - `commitments`: A vector of KZG commitments.
///
/// # Returns
///
/// - `Vec<KZGCommitment>`: Vector of KZG commitments for runtime.
pub fn commitments_to_runtime(commitments: Vec<KZGCommitmentT>) -> Vec<KZGCommitment> {
	commitments
		.iter()
		.map(|c| KZGCommitment { inner: c.to_bytes() })
		.collect::<Vec<_>>()
}

/// Converts KZG proofs to a runtime-friendly format.
///
/// # Arguments
///
/// - `proofs`: A vector of KZG proofs.
///
/// # Returns
///
/// - `Vec<KZGProof>`: Vector of KZG proofs for runtime.
pub fn proofs_to_runtime(proofs: Vec<KZGProofT>) -> Vec<KZGProof> {
	proofs.iter().map(|c| KZGProof { inner: c.to_bytes() }).collect::<Vec<_>>()
}

/// Waits for two block confirmations using a client subscription.
///
/// # Arguments
///
/// - `client`: A reference to the client object.
///
/// # Returns
///
/// - `Result<(), Box<dyn std::error::Error>>`: A result indicating success or failure.
pub async fn wait_for_block(client: &Client) -> Result<(), Box<dyn std::error::Error>> {
    let mut sub = client.api.rpc().subscribe_all_block_headers().await?;
    sub.next().await;
	sub.next().await;
	
	Ok(())
}

/// Information messages used across the module.
pub mod info_msg {
	pub const START_EXAMPLE: &str = "üåü Start";
	pub const ERROR: &str = "‚ùå Error";
	pub const SUCCESS: &str = "‚úÖ Success";
	pub const ALL_SUCCESS: &str = "üíØ All success";
	pub const HOURGLASS: &str = "‚è≥";
}