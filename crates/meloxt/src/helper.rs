// Copyright 2023 ZeroDAO

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//     http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use crate::{
	melodot::runtime_types::{
		melo_core_primitives::sidecar::SidecarMetadata,
		melo_das_primitives::{
			crypto::{BlsScalar, KZGCommitment, KZGProof, Position},
			segment::{Segment, SegmentData},
		},
		melo_proof_of_space::{
			cell::{Cell, CellMetadata, PreCell},
			piece::{PieceMetadata, PiecePosition},
		},
	},
	Client,
};
use melo_core_primitives::SidecarMetadata as SidecarMetadataT;
use melo_das_primitives::{
	crypto::{BlsScalar as BlsScalarT, KZGCommitment as KZGCommitmentT, KZGProof as KZGProofT},
	segment::Segment as SegmentT,
};
use melo_proof_of_space::{
	cell::{Cell as CellT, PreCell as PreCellT},
	piece::PiecePosition as PiecePositionT,
};

pub use primitive_types::H256;

/// Converts a given byte length to sidecar metadata suitable for runtime.
///
/// # Arguments
///
/// - `bytes_len`: Length of random bytes to generate.
///
/// # Returns
///
/// - `Vec<KZGCommitment>`: Vector of KZG commitments for runtime.
/// - `Vec<KZGProof>`: Vector of KZG proofs for runtime.
/// - `H256`: Hash value of the blobs.
/// - `Vec<u8>`: Randomly generated bytes.
pub fn sidecar_metadata_runtime(
	bytes_len: u32,
	app_id: u32,
	nonce: u32,
) -> (SidecarMetadata, Vec<u8>) {
	let (metadata, bytes) = sidecar_metadata(bytes_len, app_id, nonce);
	(sidecar_metadata_to_runtime(&metadata), bytes)
}

pub fn sidecar_metadata_to_runtime(metadata: &SidecarMetadataT) -> SidecarMetadata {
	SidecarMetadata {
		commitments: commitments_to_runtime(metadata.commitments.clone()),
		proofs: proofs_to_runtime(metadata.proofs.clone()),
		app_id: metadata.app_id,
		nonce: metadata.nonce,
		bytes_len: metadata.bytes_len,
	}
}

pub fn pre_cell_to_runtime(pre_cell: &PreCellT) -> PreCell {
	PreCell {
		position: piece_position_to_runtime(&pre_cell.position),
		seg: Segment {
			position: Position { x: pre_cell.seg.position.x, y: pre_cell.seg.position.y },
			content: SegmentData {
				proof: KZGProof { inner: pre_cell.seg.content.proof.to_bytes() },
				data: bls_scalars_to_runtime(&pre_cell.seg.content.data),
			},
		},
	}
}

pub fn cell_to_runtime(cell: &CellT<u32>) -> Cell<u32> {
	Cell {
		metadata: CellMetadata {
			piece_metadata: piece_metadata_to_runtime(
				&cell.metadata.piece_metadata.pos,
				cell.metadata.piece_metadata.block_num,
			),
			offset: cell.metadata.offset,
		},
		seg: Segment {
			position: Position { x: cell.seg.position.x, y: cell.seg.position.y },
			content: SegmentData {
				proof: KZGProof { inner: cell.seg.content.proof.to_bytes() },
				data: bls_scalars_to_runtime(&cell.seg.content.data),
			},
		},
	}
}

/// Generates sidecar metadata based on a given byte length.
///
/// # Arguments
///
/// - `bytes_len`: Length of random bytes to generate.
///
/// # Returns
///
/// - `Vec<KZGCommitmentT>`: Vector of KZG commitments.
/// - `Vec<KZGProofT>`: Vector of KZG proofs.
/// - `H256`: Hash value of the blobs.
/// - `Vec<u8>`: Randomly generated bytes.
pub fn sidecar_metadata(bytes_len: u32, app_id: u32, nonce: u32) -> (SidecarMetadataT, Vec<u8>) {
	let bytes = (0..bytes_len).map(|_| rand::random::<u8>()).collect::<Vec<u8>>();
	(SidecarMetadataT::try_from_app_data(&bytes, app_id, nonce).unwrap(), bytes)
}

/// Converts KZG commitments to a runtime-friendly format.
///
/// # Arguments
///
/// - `commitments`: A vector of KZG commitments.
///
/// # Returns
///
/// - `Vec<KZGCommitment>`: Vector of KZG commitments for runtime.
pub fn commitments_to_runtime(commitments: Vec<KZGCommitmentT>) -> Vec<KZGCommitment> {
	commitments
		.iter()
		.map(|c| KZGCommitment { inner: c.to_bytes() })
		.collect::<Vec<_>>()
}

pub fn bls_scalars_to_runtime(scalars: &[BlsScalarT]) -> Vec<BlsScalar> {
	scalars.iter().map(|c| BlsScalar { inner: c.to_bytes() }).collect::<Vec<_>>()
}

pub fn piece_position_to_runtime(pos: &PiecePositionT) -> PiecePosition {
	match pos {
		PiecePositionT::Row(row) => PiecePosition::Row(*row),
		PiecePositionT::Column(column) => PiecePosition::Column(*column),
	}
}

pub fn piece_metadata_to_runtime(
	pos: &PiecePositionT,
	block_num: u32,
) -> PieceMetadata<u32> {
	PieceMetadata { pos: piece_position_to_runtime(pos), block_num }
}

pub fn segment_to_runtime(segment: &SegmentT) -> Segment {
	Segment {
		position: Position { x: segment.position.x, y: segment.position.y },
		content: SegmentData {
			proof: KZGProof { inner: segment.content.proof.to_bytes() },
			data: bls_scalars_to_runtime(segment.content.data.as_slice()),
		},
	}
}

/// Converts KZG proofs to a runtime-friendly format.
///
/// # Arguments
///
/// - `proofs`: A vector of KZG proofs.
///
/// # Returns
///
/// - `Vec<KZGProof>`: Vector of KZG proofs for runtime.
pub fn proofs_to_runtime(proofs: Vec<KZGProofT>) -> Vec<KZGProof> {
	proofs.iter().map(|c| KZGProof { inner: c.to_bytes() }).collect::<Vec<_>>()
}

/// Waits for two block confirmations using a client subscription.
///
/// # Arguments
///
/// - `client`: A reference to the client object.
///
/// # Returns
///
/// - `Result<(), Box<dyn std::error::Error>>`: A result indicating success or failure.
pub async fn wait_for_block(client: &Client) -> Result<(), Box<dyn std::error::Error>> {
	let mut sub = client.api.rpc().subscribe_all_block_headers().await?;
	sub.next().await;
	sub.next().await;

	Ok(())
}

/// Information messages used across the module.
pub mod info_msg {
	pub const START_EXAMPLE: &str = "üåü Start";
	pub const ERROR: &str = "‚ùå Error";
	pub const SUCCESS: &str = "‚úÖ Success";
	pub const ALL_SUCCESS: &str = "üíØ All success";
	pub const HOURGLASS: &str = "‚è≥";
}
