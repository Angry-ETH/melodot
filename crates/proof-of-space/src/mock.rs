// Copyright 2023 ZeroDAO

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//     http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


use melo_das_primitives::{BlsScalar, KZGProof, Position, Segment, SegmentData};
pub const BLS_SCALAR11: [u8; 31] = [
	29, 156, 25, 98, 197, 88, 212, 149, 71, 118, 79, 160, 2, 113, 136, 113, 71, 178, 194, 144, 233,
	46, 209, 248, 243, 157, 209, 52, 151, 112, 161,
];
pub const BLS_SCALAR12: [u8; 31] = [
	220, 110, 142, 193, 202, 15, 252, 233, 219, 92, 54, 44, 165, 65, 146, 231, 160, 21, 76, 147,
	62, 100, 8, 173, 253, 129, 76, 140, 98, 96, 243,
];
pub const Y1: u32 = 593679093;
pub const Z1: u16 = 39055;
pub const BLOCK_HASH1: [u8; 32] = [
	185, 48, 202, 209, 31, 96, 96, 123, 203, 191, 57, 182, 188, 140, 107, 180, 173, 59, 186, 11,
	163, 130, 12, 159, 45, 57, 51, 10, 207, 119, 216, 45,
];
pub const COMMIT1: [u8; 48] = [
	164, 42, 54, 182, 102, 224, 65, 135, 217, 81, 200, 88, 149, 72, 225, 107, 53, 147, 60, 103,
	151, 142, 163, 132, 6, 247, 209, 73, 85, 83, 133, 122, 77, 75, 138, 140, 225, 216, 153, 184,
	183, 82, 55, 235, 146, 212, 98, 63,
];
pub const PROOF_11: [u8; 48] = [
	135, 91, 139, 218, 142, 148, 177, 147, 213, 209, 249, 168, 125, 50, 109, 6, 47, 204, 88, 186,
	122, 238, 185, 252, 23, 92, 129, 210, 142, 196, 96, 152, 255, 95, 250, 75, 201, 33, 203, 183,
	226, 171, 129, 34, 63, 214, 246, 24,
];
pub const PROOF_12: [u8; 48] = [
	178, 86, 254, 145, 193, 204, 195, 141, 82, 11, 245, 32, 69, 62, 53, 144, 166, 130, 43, 155,
	185, 94, 229, 223, 96, 122, 118, 129, 193, 55, 247, 28, 137, 202, 254, 92, 193, 45, 87, 106,
	66, 192, 168, 141, 164, 88, 106, 232,
];

pub const BLS_SCALAR21: [u8; 31] = [
	82, 135, 129, 96, 11, 177, 176, 202, 197, 230, 88, 161, 66, 146, 93, 134, 20, 206, 136, 92,
	235, 240, 212, 117, 6, 2, 100, 178, 67, 191, 201,
];
pub const BLS_SCALAR22: [u8; 31] = [
	77, 1, 112, 171, 221, 219, 160, 84, 164, 142, 139, 112, 120, 17, 156, 201, 184, 136, 86, 70,
	76, 12, 20, 133, 33, 209, 252, 189, 102, 15, 15,
];
pub const Y2: u32 = 417082944;
pub const Z2: u16 = 31943;
pub const BLOCK_HASH2: [u8; 32] = [
	249, 131, 236, 201, 100, 87, 58, 143, 140, 152, 119, 109, 158, 136, 211, 117, 76, 218, 52, 127,
	209, 194, 117, 140, 86, 161, 110, 203, 194, 191, 167, 99,
];
pub const COMMIT2: [u8; 48] = [
	166, 196, 203, 19, 219, 202, 251, 249, 36, 33, 205, 196, 24, 33, 231, 249, 101, 116, 144, 158,
	125, 33, 55, 56, 154, 16, 171, 149, 204, 51, 216, 173, 185, 99, 44, 192, 168, 252, 117, 224,
	44, 193, 183, 72, 112, 202, 111, 43,
];
pub const PROOF_21: [u8; 48] = [
	180, 120, 56, 185, 213, 199, 10, 130, 102, 226, 163, 99, 56, 110, 52, 202, 225, 67, 233, 51,
	144, 22, 19, 203, 23, 114, 86, 165, 170, 252, 55, 191, 240, 14, 192, 189, 154, 10, 152, 225,
	161, 13, 72, 226, 73, 81, 180, 29,
];
pub const PROOF_22: [u8; 48] = [
	161, 209, 214, 15, 190, 191, 117, 109, 133, 71, 168, 106, 118, 235, 209, 138, 21, 72, 59, 5,
	57, 23, 54, 65, 24, 182, 179, 169, 156, 137, 168, 95, 167, 89, 117, 8, 255, 154, 93, 45, 68,
	217, 126, 68, 118, 36, 65, 67,
];

pub const BLS_SCALAR31: [u8; 31] = [
	162, 139, 56, 191, 234, 189, 73, 195, 203, 235, 97, 217, 147, 19, 134, 198, 17, 134, 179, 44,
	124, 181, 20, 170, 157, 236, 155, 29, 121, 183, 71,
];
pub const BLS_SCALAR32: [u8; 31] = [
	195, 200, 22, 51, 194, 192, 86, 186, 205, 33, 165, 175, 128, 4, 86, 63, 168, 177, 183, 45, 209,
	69, 134, 131, 81, 7, 18, 62, 85, 243, 202,
];
pub const Y3: u32 = 3213832640;
pub const Z3: u16 = 58239;
pub const BLOCK_HASH3: [u8; 32] = [
	227, 230, 144, 116, 199, 75, 98, 65, 36, 24, 136, 110, 69, 236, 83, 200, 121, 22, 55, 183, 79,
	141, 110, 250, 112, 37, 161, 217, 186, 23, 139, 136,
];
pub const COMMIT3: [u8; 48] = [
	164, 238, 93, 21, 16, 69, 40, 130, 136, 148, 88, 54, 235, 215, 20, 109, 204, 17, 98, 33, 3,
	194, 187, 129, 188, 201, 253, 165, 100, 253, 115, 184, 142, 84, 171, 217, 228, 197, 217, 184,
	88, 217, 188, 140, 77, 26, 211, 223,
];
pub const PROOF_31: [u8; 48] = [
	139, 184, 236, 0, 129, 224, 220, 162, 78, 128, 53, 230, 247, 40, 200, 166, 172, 47, 38, 146,
	44, 232, 3, 164, 109, 10, 95, 130, 224, 105, 8, 43, 225, 248, 221, 236, 185, 14, 244, 254, 255,
	48, 5, 87, 156, 89, 189, 117,
];
pub const PROOF_32: [u8; 48] = [
	185, 2, 128, 170, 250, 227, 222, 49, 185, 166, 100, 44, 19, 240, 191, 95, 85, 55, 248, 177, 96,
	210, 104, 135, 36, 171, 36, 164, 26, 126, 28, 97, 99, 39, 14, 128, 228, 80, 219, 248, 87, 212,
	31, 209, 199, 183, 143, 244,
];

pub fn get_mock_seg(first: &[u8; 31], x: u32, y: u32, proof: &[u8; 48], size: usize) -> Segment {
	let mut b = vec![];
	for _ in 0..size {
		b.push(BlsScalar::from([1u8; 31]));
	}
	b[0] = BlsScalar::from(*first);
	let position = Position { x, y };
	Segment {
		position,
		content: SegmentData { data: b, proof: KZGProof::try_from(proof).unwrap() },
	}
}

pub fn get_mock_row(
	b1: &[u8; 31],
	b2: &[u8; 31],
	y: u32,
	proof1: &[u8; 48],
	proof2: &[u8; 48],
	size: usize,
) -> Vec<Segment> {
	let mut row = vec![];
	for i in 0..size {
		let mut seg = Segment::default();
		seg.position.x = i as u32;
		seg.position.y = y;
		row.push(Segment::default());
	}
	row[0] = get_mock_seg(b1, 0, y, proof1, size);
	row[1] = get_mock_seg(b2, 1, y, proof2, size);
	row
}
